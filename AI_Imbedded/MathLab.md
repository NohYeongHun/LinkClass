# 행렬과 선형대수

### 23이하의 소수들로 구성된 3*3 행렬, A를 구성하라.
- prime(x) : x의 소수를 나타내어라
- A(end, :) : A의 마지막행의 전체열
- A(2:3, 2:3) : A의 2~3번째행의, 2~3번째열
- 
- A(3:-1:1,end) // 3행을 선택해라 -1칸씩 띄어서 선택해라 1행까지, end(데이터의 끝부분을 선택)
- A(:,:) // A행렬의 모든 열과 행을 보여주어라.
- A(:) // A행의 모든 인덱스를 열형태로 보여주어라.
- size(A) // A행의 행 열을 출력하라.
- primes(x) // x이하의 모든 소수들을 출력하여라.<br>
ex) A를 3행 3열 형태로 만들고 A(:)=primes(23)을 입력하면 primes(23)이 A에 3행 3열의 형태로 들어간다.
- size(A,1) // A의 행의 개수를 출력하여라.
- size(A,2) // A의 열의 개수를 출력하여라.
- zeros(x) // x행 x열을 0으로 모두 채워라.
- zeros(x,y) // x행 y열을 0으로 모두 채워라.
- A([x:y],[x:y]) // A의 x행부터 y행까지, x열부터 y열까지에 포함되는 행렬을 나타내어라.
- A(2,[2:4]) // A의 2행과 A의 2열부터 4열까지에 포함되는 행렬을 나타내어라.
- magic(x) // x행 x열을 가진 행렬을 나타내어라.
- A(x, :) = [] // A의 X행을 제외한 나머지를 나타내어라.

## rand와 randn사용 불규칙 행렬생성
- rand(x) // x행 x열의 랜덤값이 들어간 행렬 생성

## 특정행렬 반복 행렬 만들기
- B = [1 2 ; 3 4]
- repmat(B,2) // B가 2*2번 반복되는 행렬 생성

## 블록 대각행렬을 만들기.
- blkdiag(eye(2)) // eye(2)인 블록대각행렬 생성
- blkdiag(eye(2),ones(2)) // eye(2),  ones(2)가 포함된 블록대각행렬 생성.
=> [1 0 0 0 ; 0 1 0 0 ; 0 0 1 1 ; 0 0 1 1]
- diag(x) x리스트를 대각행렬로 표현

```math
>> A = [2 3 5 ;
7 11 13;
17 19 23]

A =

     2     3     5
     7    11    13
    17    19    23

>> A(3,:)

ans =

    17    19    23

>> A(end,:)

ans =

    17    19    23

>> A(:,3)

ans =

     5
    13
    23

>> A(2:3, 2:3)

ans =

    11    13
    19    23

>> A

A =

     2     3     5
     7    11    13
    17    19    23

>> A(2:3, 2:3)

ans =

    11    13
    19    23

>> A(3:-1:1,end) // 3열 ->reverse -> 인덱스 1부터 끝까지 가져오라 
>>A(:,:) // A행렬의 모든 열과 행을 보여주어라.
>>A(:) // A행의 모든 인덱스를 열형태로 보여주어라.
>>size(A) // A행의 행 열을 출력하라.
ans =

    23
    13
     5

>> 3:-1:1

ans =

     3     2     1

>> A(3:-1:1,end) (A의 3열을 뒤집어서 끝까지 보여줘라??)

ans =

    23
    13
     5
A =
2 3 5
7 11 13
17 19 23
>>A([1,3],[2,3]) // A의 1행,3행과 2열 3열에 해당하는 값들을 출력해라.
=> A([1,3]) => [2 3 5] [ 17 19 23]
=> A([2,3]) => [3 11 19] [5 13 23]
=> A([1,3],[2,3]) => [3 5] [19 23 ]

A = primes(23)

A =

     2     3     5     7    11    13    17    19    23

>> size(A)

ans =

     1     9

>> size(A,1) # A의 행

ans =

     1

>> size(A,2) # A의 열 개수

ans =

     9>> A = zeros(3,3)

A =

     0     0     0
     0     0     0
     0     0     0

>> A(:)=primes(23)

A =

     2     7    17
     3    11    19
     5    13    23

>> A(:)=primes(30)
좌변과 우변의 요소 개수가 다르기 때문에 값을 대입할 수 없습니다.

```
### 3*3 행렬 A에서 특정 행을 제거하라.
- A(3,:) = [] : A의 3번째행의 모든 열을 비워라.
```math
 A = [2 3 5; 7 11 13; 17 19 23]

A =

     2     3     5
     7    11    13
    17    19    23

>> B = []

B =

     []

>> A(3,:)=[]

A =

     2     3     5
     7    11    13

```
### rand, randn을 사용하여 불규칙 수들의 행렬을 생성하라.
```math
>> rand(3)

ans =

    0.0357    0.6787    0.3922
    0.8491    0.7577    0.6555
    0.9340    0.7431    0.1712

>> rand(3)

ans =

    0.7060    0.0462    0.6948
    0.0318    0.0971    0.3171
    0.2769    0.8235    0.9502
```

### 특정행렬이 반복되는 행렬을 만들어라.
- repmat(x,2) = x행렬을 2번 반복
- eye(x) = x차 단위행렬 생성


```math
>> eye

ans =

     1

>> eye(2)

ans =

     1     0
     0     1

>> A = eye(3)

A =

     1     0     0
     0     1     0
     0     0     1

>> repmat(A,3)

ans =

     1     0     0     1     0     0     1     0     0
     0     1     0     0     1     0     0     1     0
     0     0     1     0     0     1     0     0     1
     1     0     0     1     0     0     1     0     0
     0     1     0     0     1     0     0     1     0
     0     0     1     0     0     1     0     0     1
     1     0     0     1     0     0     1     0     0
     0     1     0     0     1     0     0     1     0
     0     0     1     0     0     1     0     0     1

>> repmat(eye(2),2)

ans =

     1     0     1     0
     0     1     0     1
     1     0     1     0
     0     1     0     1

>> A = rand(2)

A =

    0.0344    0.3816
    0.4387    0.7655

>> repmat(A,1)

ans =

    0.0344    0.3816
    0.4387    0.7655

>> repmat(A,2)

ans =

    0.0344    0.3816    0.0344    0.3816
    0.4387    0.7655    0.4387    0.7655
    0.0344    0.3816    0.0344    0.3816
    0.4387    0.7655    0.4387    0.7655

>> B = [1 2 ; 3 4]

B =

     1     2
     3     4

>> X = [B eye(2);
ones(2) zeros(2)]

X =

     1     2     1     0
     3     4     0     1
     1     1     0     0
     1     1     0     0

```

### 블록 대각행렬을 만들어라.
- blkdiag(x,y) = 행렬로 대각 블럭 다이어그램을 생성
- diag(x:y) = x부터 y까지의 원소를 대각선으로 가지는 행렬 생성
ex)
```math
>> blkdiag(eye(2))

ans =

     1     0
     0     1

>> blkdiag(1,3)

ans =

     1     0
     0     3

diag(1:10)

ans =

     1     0     0     0     0     0     0     0     0     0
     0     2     0     0     0     0     0     0     0     0
     0     0     3     0     0     0     0     0     0     0
     0     0     0     4     0     0     0     0     0     0
     0     0     0     0     5     0     0     0     0     0
     0     0     0     0     0     6     0     0     0     0
     0     0     0     0     0     0     7     0     0     0
     0     0     0     0     0     0     0     8     0     0
     0     0     0     0     0     0     0     0     9     0
     0     0     0     0     0     0     0     0     0    10

```
### 행렬의 생성과 원소 - 특수행렬의 생성
- Toeplitz, Hankel, Gallery 행렬을 만들어라.
- toeplitz([],[])
```math
>> toeplitz([1 0 -1 -2], [1 2 4 8])

ans =

     1     2     4     8
     0     1     2     4
    -1     0     1     2
    -2    -1     0     1

>> hankel([3 1 2 0 ], [0 -1 -2 -3])

ans =

     3     1     2     0
     1     2     0    -1
     2     0    -1    -2
     0    -1    -2    -3

>> gallery(3)

ans =

  -149   -50  -154
   537   180   546
   -27    -9   -25

>> A = gallery('moler',5)

A =

     1    -1    -1    -1    -1
    -1     2     0     0     0
    -1     0     3     1     1
    -1     0     1     4     2
    -1     0     1     2     5
```
### 배열 연산 A*x = B를 만족하는 x를 구하여라
- x = A^(-1)*B
```math
A = [1 2 ; 3 4]
B = [1 1 ; 1 1]
x = inv(A)*B
```

### 배열 연산(차원이 다른 두 행렬의 kronecker 곱)
- kronecker() :

``` math
>> A = [1 10; -10 100]

A =

     1    10
   -10   100

>> B = [1 2 3; 4 5 6; 7 8 9]

B =

     1     2     3
     4     5     6
     7     8     9

>> kron(A,B)

ans =

     1     2     3    10    20    30
     4     5     6    40    50    60
     7     8     9    70    80    90
   -10   -20   -30   100   200   300
   -40   -50   -60   400   500   600
   -70   -80   -90   700   800   900
```

### 행렬내외부 원소에 대한 연산
- sqrt(A) : A의 내부 원소에 대해 루트를 씌운다
- sqrtm(A) : A의 행렬에 대해 루트를 씌운다.

### 행렬 처리
- diag()
```math
>> A = [1 4 9; 16 25 36]

A =

     1     4     9
    16    25    36

>> B = reshape(A,3,2)

B =

     1    25
    16     9
     4    36

>> A(:)

ans =

     1
    16
     4
    25
     9
    36

>> diag([1 2 3])

ans =

     1     0     0
     0     2     0
     0     0     3

>> help diag
diag - 대각 행렬을 생성하거나 행렬의 대각선 요소 가져오기

    주대각선에 벡터 v의 요소를 가진 정사각 대각 행렬을 반환합니다.

    D = diag(v)
    D = diag(v,k)
    x = diag(A)
    x = diag(A,k)

    참고 항목 blkdiag, isdiag, istril, istriu, spdiags, tril, triu

    diag에 대한 문서
    이름이 diag인 다른 함수

>> diag([1, 2,3],1)

ans =

     0     1     0     0
     0     0     2     0
     0     0     0     3
     0     0     0     0
```

### 성긴 행렬(Sparse Matrices)
- 0이 아닌 원소들의 수를 계산하라.
- sparse() : 0이 아닌 원소들을 0을 표현하지 않고 표현하기 위한 함수.
- nnz(A) : A의 0이 아닌 원소들의 개수 
```MATH
A = sparse([1 2 2 4 4], [3 1 4 2 4], 1:5)

# sparse() 형태
A =

   (2,1)        2
   (4,2)        4
   (1,3)        1
   (2,4)        3
   (4,4)        5

>> B = full(A)
# A의 full 행렬 보여주기
B =

     0     0     1     0
     2     0     0     3
     0     0     0     0
     0     4     0     5

```

### Sparse Matrix에서 diag의 유사 형태인 spdiags에 대해 이해하자.
- spdiags() :<br>

```math
>>  B = [1 2 0; 1 2 3; 0 2 3; 0 2 3]

B =

     1     2     0
     1     2     3
     0     2     3
     0     2     3

>> d = [-2 0 1]

d =

    -2     0     1

>> A = spdiags(B,d,4,4)

A =

   (1,1)        2
   (3,1)        1
   (1,2)        3
   (2,2)        2
   (4,2)        1
   (2,3)        3
   (3,3)        2
   (3,4)        3
   (4,4)        2

>> full(A)

ans =

     2     3     0     0
     0     2     3     0
     1     0     2     3
     0     1     0     2

[B,d]=spdiags(A)

B =

     1     2     0
     1     2     3
     0     2     3
     0     2     3


d =

    -2
     0
     1
```

### Airfoil data를 불러와서 Sparse Matrix를 가시화하라.
- load airfoil
```math
>> load airfoil
>> plot(x,y,'.')
>> [i(1:5) j(1:5)]

ans =

     1     2
     2     3
     3    10
     5    10
     4    11

>> [i(1:5) j(1:5)]'

ans =

     1     2     3     5     4
     2     3    10    10    11

>> A=sparse(i,j,1);
>> spy(A)
>> gplot(A,[x y])
>> axis off
```

### 선형 방정식 시스템
- 선형방정식의 해를 구하여라.
```math
x1 + 2*x3 = 3;
3*x1 + 4*x2 +x3 =1;
-2*x1 + x2+ 3*x3 =2;
>> A = [1 0 2; 3 4 1; -2 1 3]

A =

     1     0     2
     3     4     1
    -2     1     3

>> rank(A)

ans =

     3

>> B = [3 1 2]'

B =

     3
     1
     2

>> x=A\B

x =

    0.5758
   -0.4848
    1.2121

>> A = [1 1 1; 1 1 -1]

A =

     1     1     1
     1     1    -1

>> B = [3 1]'

B =

     3
     1

>> x = A\B

x =

    2.0000
         0
    1.0000
```

### 치환 및 삼각행렬
